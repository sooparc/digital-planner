{"ast":null,"code":"'use client';\n\nimport { useCallback, useState, useEffect } from 'react';\nimport { useWindowEvent } from '../use-window-event/use-window-event.mjs';\nfunction serializeJSON(value, hookName = \"use-local-storage\") {\n  try {\n    return JSON.stringify(value);\n  } catch (error) {\n    throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);\n  }\n}\nfunction deserializeJSON(value) {\n  try {\n    return value && JSON.parse(value);\n  } catch {\n    return value;\n  }\n}\nfunction createStorageHandler(type) {\n  const getItem = key => {\n    try {\n      return window[type].getItem(key);\n    } catch (error) {\n      console.warn(\"use-local-storage: Failed to get value from storage, localStorage is blocked\");\n      return null;\n    }\n  };\n  const setItem = (key, value) => {\n    try {\n      window[type].setItem(key, value);\n    } catch (error) {\n      console.warn(\"use-local-storage: Failed to set value to storage, localStorage is blocked\");\n    }\n  };\n  const removeItem = key => {\n    try {\n      window[type].removeItem(key);\n    } catch (error) {\n      console.warn(\"use-local-storage: Failed to remove value from storage, localStorage is blocked\");\n    }\n  };\n  return {\n    getItem,\n    setItem,\n    removeItem\n  };\n}\nfunction createStorage(type, hookName) {\n  const eventName = type === \"localStorage\" ? \"mantine-local-storage\" : \"mantine-session-storage\";\n  const {\n    getItem,\n    setItem,\n    removeItem\n  } = createStorageHandler(type);\n  return function useStorage({\n    key,\n    defaultValue,\n    getInitialValueInEffect = true,\n    sync = true,\n    deserialize = deserializeJSON,\n    serialize = value => serializeJSON(value, hookName)\n  }) {\n    const readStorageValue = useCallback(skipStorage => {\n      let storageBlockedOrSkipped;\n      try {\n        storageBlockedOrSkipped = typeof window === \"undefined\" || !(type in window) || window[type] === null || !!skipStorage;\n      } catch (_e) {\n        storageBlockedOrSkipped = true;\n      }\n      if (storageBlockedOrSkipped) {\n        return defaultValue;\n      }\n      const storageValue = getItem(key);\n      return storageValue !== null ? deserialize(storageValue) : defaultValue;\n    }, [key, defaultValue]);\n    const [value, setValue] = useState(readStorageValue(getInitialValueInEffect));\n    const setStorageValue = useCallback(val => {\n      if (val instanceof Function) {\n        setValue(current => {\n          const result = val(current);\n          setItem(key, serialize(result));\n          window.dispatchEvent(new CustomEvent(eventName, {\n            detail: {\n              key,\n              value: val(current)\n            }\n          }));\n          return result;\n        });\n      } else {\n        setItem(key, serialize(val));\n        window.dispatchEvent(new CustomEvent(eventName, {\n          detail: {\n            key,\n            value: val\n          }\n        }));\n        setValue(val);\n      }\n    }, [key]);\n    const removeStorageValue = useCallback(() => {\n      removeItem(key);\n      window.dispatchEvent(new CustomEvent(eventName, {\n        detail: {\n          key,\n          value: defaultValue\n        }\n      }));\n    }, []);\n    useWindowEvent(\"storage\", event => {\n      if (sync) {\n        if (event.storageArea === window[type] && event.key === key) {\n          setValue(deserialize(event.newValue ?? void 0));\n        }\n      }\n    });\n    useWindowEvent(eventName, event => {\n      if (sync) {\n        if (event.detail.key === key) {\n          setValue(event.detail.value);\n        }\n      }\n    });\n    useEffect(() => {\n      if (defaultValue !== void 0 && value === void 0) {\n        setStorageValue(defaultValue);\n      }\n    }, [defaultValue, value, setStorageValue]);\n    useEffect(() => {\n      const val = readStorageValue();\n      val !== void 0 && setStorageValue(val);\n    }, [key]);\n    return [value === void 0 ? defaultValue : value, setStorageValue, removeStorageValue];\n  };\n}\nfunction readValue(type) {\n  const {\n    getItem\n  } = createStorageHandler(type);\n  return function read({\n    key,\n    defaultValue,\n    deserialize = deserializeJSON\n  }) {\n    let storageBlockedOrSkipped;\n    try {\n      storageBlockedOrSkipped = typeof window === \"undefined\" || !(type in window) || window[type] === null;\n    } catch (_e) {\n      storageBlockedOrSkipped = true;\n    }\n    if (storageBlockedOrSkipped) {\n      return defaultValue;\n    }\n    const storageValue = getItem(key);\n    return storageValue !== null ? deserialize(storageValue) : defaultValue;\n  };\n}\nexport { createStorage, readValue };","map":{"version":3,"names":["serializeJSON","value","hookName","JSON","stringify","error","Error","deserializeJSON","parse","createStorageHandler","type","getItem","key","window","console","warn","setItem","removeItem","createStorage","eventName","useStorage","defaultValue","getInitialValueInEffect","sync","deserialize","serialize","readStorageValue","useCallback","skipStorage","storageBlockedOrSkipped","_e","storageValue","setValue","useState","setStorageValue","val","Function","current","result","dispatchEvent","CustomEvent","detail","removeStorageValue","useWindowEvent","event","storageArea","newValue","useEffect","readValue","read"],"sources":["C:\\Users\\Soojin Park\\Desktop\\digital-planner\\node_modules\\@mantine\\hooks\\src\\use-local-storage\\create-storage.ts"],"sourcesContent":["/* eslint-disable no-console */\nimport { useCallback, useEffect, useState } from 'react';\nimport { useWindowEvent } from '../use-window-event/use-window-event';\n\nexport type StorageType = 'localStorage' | 'sessionStorage';\n\nexport interface StorageProperties<T> {\n  /** Storage key */\n  key: string;\n\n  /** Default value that will be set if value is not found in storage */\n  defaultValue?: T;\n\n  /** If set to true, value will be updated in useEffect after mount. Default value is true. */\n  getInitialValueInEffect?: boolean;\n\n  /** Determines whether the value must be synced between browser tabs, `true` by default */\n  sync?: boolean;\n\n  /** Function to serialize value into string to be save in storage */\n  serialize?: (value: T) => string;\n\n  /** Function to deserialize string value from storage to value */\n  deserialize?: (value: string | undefined) => T;\n}\n\nfunction serializeJSON<T>(value: T, hookName: string = 'use-local-storage') {\n  try {\n    return JSON.stringify(value);\n  } catch (error) {\n    throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);\n  }\n}\n\nfunction deserializeJSON(value: string | undefined) {\n  try {\n    return value && JSON.parse(value);\n  } catch {\n    return value;\n  }\n}\n\nfunction createStorageHandler(type: StorageType) {\n  const getItem = (key: string) => {\n    try {\n      return window[type].getItem(key);\n    } catch (error) {\n      console.warn('use-local-storage: Failed to get value from storage, localStorage is blocked');\n      return null;\n    }\n  };\n\n  const setItem = (key: string, value: string) => {\n    try {\n      window[type].setItem(key, value);\n    } catch (error) {\n      console.warn('use-local-storage: Failed to set value to storage, localStorage is blocked');\n    }\n  };\n\n  const removeItem = (key: string) => {\n    try {\n      window[type].removeItem(key);\n    } catch (error) {\n      console.warn(\n        'use-local-storage: Failed to remove value from storage, localStorage is blocked'\n      );\n    }\n  };\n\n  return { getItem, setItem, removeItem };\n}\n\nexport function createStorage<T>(type: StorageType, hookName: string) {\n  const eventName = type === 'localStorage' ? 'mantine-local-storage' : 'mantine-session-storage';\n  const { getItem, setItem, removeItem } = createStorageHandler(type);\n\n  return function useStorage({\n    key,\n    defaultValue,\n    getInitialValueInEffect = true,\n    sync = true,\n    deserialize = deserializeJSON,\n    serialize = (value: T) => serializeJSON(value, hookName),\n  }: StorageProperties<T>) {\n    const readStorageValue = useCallback(\n      (skipStorage?: boolean): T => {\n        let storageBlockedOrSkipped;\n\n        try {\n          storageBlockedOrSkipped =\n            typeof window === 'undefined' ||\n            !(type in window) ||\n            window[type] === null ||\n            !!skipStorage;\n        } catch (_e) {\n          storageBlockedOrSkipped = true;\n        }\n\n        if (storageBlockedOrSkipped) {\n          return defaultValue as T;\n        }\n\n        const storageValue = getItem(key);\n        return storageValue !== null ? deserialize(storageValue) : (defaultValue as T);\n      },\n      [key, defaultValue]\n    );\n\n    const [value, setValue] = useState<T>(readStorageValue(getInitialValueInEffect));\n\n    const setStorageValue = useCallback(\n      (val: T | ((prevState: T) => T)) => {\n        if (val instanceof Function) {\n          setValue((current) => {\n            const result = val(current);\n            setItem(key, serialize(result));\n            window.dispatchEvent(\n              new CustomEvent(eventName, { detail: { key, value: val(current) } })\n            );\n            return result;\n          });\n        } else {\n          setItem(key, serialize(val));\n          window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: val } }));\n          setValue(val);\n        }\n      },\n      [key]\n    );\n\n    const removeStorageValue = useCallback(() => {\n      removeItem(key);\n      window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: defaultValue } }));\n    }, []);\n\n    useWindowEvent('storage', (event) => {\n      if (sync) {\n        if (event.storageArea === window[type] && event.key === key) {\n          setValue(deserialize(event.newValue ?? undefined));\n        }\n      }\n    });\n\n    useWindowEvent(eventName, (event) => {\n      if (sync) {\n        if (event.detail.key === key) {\n          setValue(event.detail.value);\n        }\n      }\n    });\n\n    useEffect(() => {\n      if (defaultValue !== undefined && value === undefined) {\n        setStorageValue(defaultValue);\n      }\n    }, [defaultValue, value, setStorageValue]);\n\n    useEffect(() => {\n      const val = readStorageValue();\n      val !== undefined && setStorageValue(val);\n    }, [key]);\n\n    return [value === undefined ? defaultValue : value, setStorageValue, removeStorageValue] as [\n      T,\n      (val: T | ((prevState: T) => T)) => void,\n      () => void,\n    ];\n  };\n}\n\nexport function readValue(type: StorageType) {\n  const { getItem } = createStorageHandler(type);\n\n  return function read<T>({\n    key,\n    defaultValue,\n    deserialize = deserializeJSON,\n  }: StorageProperties<T>) {\n    let storageBlockedOrSkipped;\n\n    try {\n      storageBlockedOrSkipped =\n        typeof window === 'undefined' || !(type in window) || window[type] === null;\n    } catch (_e) {\n      storageBlockedOrSkipped = true;\n    }\n\n    if (storageBlockedOrSkipped) {\n      return defaultValue as T;\n    }\n\n    const storageValue = getItem(key);\n    return storageValue !== null ? deserialize(storageValue) : (defaultValue as T);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}