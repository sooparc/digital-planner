{"ast":null,"code":"'use client';\n\nimport { useMemo } from 'react';\nimport { useUncontrolled } from '../use-uncontrolled/use-uncontrolled.mjs';\nfunction range(start, end) {\n  const length = end - start + 1;\n  return Array.from({\n    length\n  }, (_, index) => index + start);\n}\nconst DOTS = \"dots\";\nfunction usePagination({\n  total,\n  siblings = 1,\n  boundaries = 1,\n  page,\n  initialPage = 1,\n  onChange\n}) {\n  const _total = Math.max(Math.trunc(total), 0);\n  const [activePage, setActivePage] = useUncontrolled({\n    value: page,\n    onChange,\n    defaultValue: initialPage,\n    finalValue: initialPage\n  });\n  const setPage = pageNumber => {\n    if (pageNumber <= 0) {\n      setActivePage(1);\n    } else if (pageNumber > _total) {\n      setActivePage(_total);\n    } else {\n      setActivePage(pageNumber);\n    }\n  };\n  const next = () => setPage(activePage + 1);\n  const previous = () => setPage(activePage - 1);\n  const first = () => setPage(1);\n  const last = () => setPage(_total);\n  const paginationRange = useMemo(() => {\n    const totalPageNumbers = siblings * 2 + 3 + boundaries * 2;\n    if (totalPageNumbers >= _total) {\n      return range(1, _total);\n    }\n    const leftSiblingIndex = Math.max(activePage - siblings, boundaries);\n    const rightSiblingIndex = Math.min(activePage + siblings, _total - boundaries);\n    const shouldShowLeftDots = leftSiblingIndex > boundaries + 2;\n    const shouldShowRightDots = rightSiblingIndex < _total - (boundaries + 1);\n    if (!shouldShowLeftDots && shouldShowRightDots) {\n      const leftItemCount = siblings * 2 + boundaries + 2;\n      return [...range(1, leftItemCount), DOTS, ...range(_total - (boundaries - 1), _total)];\n    }\n    if (shouldShowLeftDots && !shouldShowRightDots) {\n      const rightItemCount = boundaries + 1 + 2 * siblings;\n      return [...range(1, boundaries), DOTS, ...range(_total - rightItemCount, _total)];\n    }\n    return [...range(1, boundaries), DOTS, ...range(leftSiblingIndex, rightSiblingIndex), DOTS, ...range(_total - boundaries + 1, _total)];\n  }, [_total, siblings, activePage]);\n  return {\n    range: paginationRange,\n    active: activePage,\n    setPage,\n    next,\n    previous,\n    first,\n    last\n  };\n}\nexport { DOTS, usePagination };","map":{"version":3,"names":["range","start","end","length","Array","from","_","index","DOTS","usePagination","total","siblings","boundaries","page","initialPage","onChange","_total","Math","max","trunc","activePage","setActivePage","useUncontrolled","value","defaultValue","finalValue","setPage","pageNumber","next","previous","first","last","paginationRange","useMemo","totalPageNumbers","leftSiblingIndex","rightSiblingIndex","min","shouldShowLeftDots","shouldShowRightDots","leftItemCount","rightItemCount","active"],"sources":["C:\\Users\\Soojin Park\\Desktop\\digital-planner\\node_modules\\@mantine\\hooks\\src\\use-pagination\\use-pagination.ts"],"sourcesContent":["import { useMemo } from 'react';\nimport { useUncontrolled } from '../use-uncontrolled/use-uncontrolled';\n\nfunction range(start: number, end: number) {\n  const length = end - start + 1;\n  return Array.from({ length }, (_, index) => index + start);\n}\n\nexport const DOTS = 'dots';\n\nexport interface PaginationParams {\n  /** Page selected on initial render, defaults to 1 */\n  initialPage?: number;\n\n  /** Controlled active page number */\n  page?: number;\n\n  /** Total amount of pages */\n  total: number;\n\n  /** Siblings amount on left/right side of selected page, defaults to 1 */\n  siblings?: number;\n\n  /** Amount of elements visible on left/right edges, defaults to 1  */\n  boundaries?: number;\n\n  /** Callback fired after change of each page */\n  onChange?: (page: number) => void;\n}\n\nexport function usePagination({\n  total,\n  siblings = 1,\n  boundaries = 1,\n  page,\n  initialPage = 1,\n  onChange,\n}: PaginationParams) {\n  const _total = Math.max(Math.trunc(total), 0);\n  const [activePage, setActivePage] = useUncontrolled({\n    value: page,\n    onChange,\n    defaultValue: initialPage,\n    finalValue: initialPage,\n  });\n\n  const setPage = (pageNumber: number) => {\n    if (pageNumber <= 0) {\n      setActivePage(1);\n    } else if (pageNumber > _total) {\n      setActivePage(_total);\n    } else {\n      setActivePage(pageNumber);\n    }\n  };\n\n  const next = () => setPage(activePage + 1);\n  const previous = () => setPage(activePage - 1);\n  const first = () => setPage(1);\n  const last = () => setPage(_total);\n\n  const paginationRange = useMemo((): (number | 'dots')[] => {\n    const totalPageNumbers = siblings * 2 + 3 + boundaries * 2;\n    if (totalPageNumbers >= _total) {\n      return range(1, _total);\n    }\n\n    const leftSiblingIndex = Math.max(activePage - siblings, boundaries);\n    const rightSiblingIndex = Math.min(activePage + siblings, _total - boundaries);\n\n    const shouldShowLeftDots = leftSiblingIndex > boundaries + 2;\n    const shouldShowRightDots = rightSiblingIndex < _total - (boundaries + 1);\n\n    if (!shouldShowLeftDots && shouldShowRightDots) {\n      const leftItemCount = siblings * 2 + boundaries + 2;\n      return [...range(1, leftItemCount), DOTS, ...range(_total - (boundaries - 1), _total)];\n    }\n\n    if (shouldShowLeftDots && !shouldShowRightDots) {\n      const rightItemCount = boundaries + 1 + 2 * siblings;\n      return [...range(1, boundaries), DOTS, ...range(_total - rightItemCount, _total)];\n    }\n\n    return [\n      ...range(1, boundaries),\n      DOTS,\n      ...range(leftSiblingIndex, rightSiblingIndex),\n      DOTS,\n      ...range(_total - boundaries + 1, _total),\n    ];\n  }, [_total, siblings, activePage]);\n\n  return {\n    range: paginationRange,\n    active: activePage,\n    setPage,\n    next,\n    previous,\n    first,\n    last,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}