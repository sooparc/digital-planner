{"ast":null,"code":"'use client';\n\nimport { useCallback } from 'react';\nfunction assignRef(ref, value) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  } else if (typeof ref === \"object\" && ref !== null && \"current\" in ref) {\n    ref.current = value;\n  }\n}\nfunction mergeRefs(...refs) {\n  const cleanupMap = /* @__PURE__ */new Map();\n  return node => {\n    refs.forEach(ref => {\n      const cleanup = assignRef(ref, node);\n      if (cleanup) {\n        cleanupMap.set(ref, cleanup);\n      }\n    });\n    if (cleanupMap.size > 0) {\n      return () => {\n        refs.forEach(ref => {\n          const cleanup = cleanupMap.get(ref);\n          if (cleanup) {\n            cleanup();\n          } else {\n            assignRef(ref, null);\n          }\n        });\n        cleanupMap.clear();\n      };\n    }\n  };\n}\nfunction useMergedRef(...refs) {\n  return useCallback(mergeRefs(...refs), refs);\n}\nexport { assignRef, mergeRefs, useMergedRef };","map":{"version":3,"names":["assignRef","ref","value","current","mergeRefs","refs","cleanupMap","Map","node","forEach","cleanup","set","size","get","clear","useMergedRef","useCallback"],"sources":["C:\\Users\\Soojin Park\\Desktop\\digital-planner\\node_modules\\@mantine\\hooks\\src\\use-merged-ref\\use-merged-ref.ts"],"sourcesContent":["import { Ref, useCallback, type RefCallback } from 'react';\n\ntype PossibleRef<T> = Ref<T> | undefined;\n\ntype RefCleanup<T> = ReturnType<RefCallback<T>>;\n\nexport function assignRef<T>(ref: PossibleRef<T>, value: T): RefCleanup<T> {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (typeof ref === 'object' && ref !== null && 'current' in ref) {\n    ref.current = value;\n  }\n}\n\nexport function mergeRefs<T>(...refs: PossibleRef<T>[]) {\n  const cleanupMap = new Map<PossibleRef<T>, Exclude<RefCleanup<T>, void>>();\n\n  return (node: T | null) => {\n    refs.forEach((ref) => {\n      const cleanup = assignRef(ref, node);\n      if (cleanup) {\n        cleanupMap.set(ref, cleanup);\n      }\n    });\n\n    if (cleanupMap.size > 0) {\n      return () => {\n        refs.forEach((ref) => {\n          const cleanup = cleanupMap.get(ref);\n          if (cleanup) {\n            cleanup();\n          } else {\n            assignRef(ref, null);\n          }\n        });\n        cleanupMap.clear();\n      };\n    }\n  };\n}\n\nexport function useMergedRef<T>(...refs: PossibleRef<T>[]) {\n  return useCallback(mergeRefs(...refs), refs);\n}\n"],"mappings":";;;AAMgB,SAAAA,UAAaC,GAAA,EAAqBC,KAAyB;EACrE,WAAOD,GAAA,KAAQ,UAAY;IAC7B,OAAOA,GAAA,CAAIC,KAAK;EAAA,WACP,OAAOD,GAAA,KAAQ,YAAYA,GAAQ,aAAQ,aAAaA,GAAK;IACtEA,GAAA,CAAIE,OAAU,GAAAD,KAAA;EAAA;AAElB;AAEO,SAASE,UAAA,GAAgBC,IAAwB;EAChD,MAAAC,UAAA,sBAAiBC,GAAkD;EAEzE,OAAQC,IAAmB;IACpBH,IAAA,CAAAI,OAAA,CAASR,GAAQ;MACd,MAAAS,OAAA,GAAUV,SAAU,CAAAC,GAAA,EAAKO,IAAI;MACnC,IAAIE,OAAS;QACAJ,UAAA,CAAAK,GAAA,CAAIV,GAAA,EAAKS,OAAO;MAAA;IAC7B,CACD;IAEG,IAAAJ,UAAA,CAAWM,IAAA,GAAO,CAAG;MACvB,OAAO,MAAM;QACNP,IAAA,CAAAI,OAAA,CAASR,GAAQ;UACd,MAAAS,OAAA,GAAUJ,UAAW,CAAAO,GAAA,CAAIZ,GAAG;UAClC,IAAIS,OAAS;YACHA,OAAA;UAAA,CACH;YACLV,SAAA,CAAUC,GAAA,EAAK,IAAI;UAAA;QACrB,CACD;QACDK,UAAA,CAAWQ,KAAM;MACnB;IAAA;EAEJ;AACF;AAEO,SAASC,aAAA,GAAmBV,IAAwB;EACzD,OAAOW,WAAY,CAAAZ,SAAA,CAAU,GAAGC,IAAI,GAAGA,IAAI;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}