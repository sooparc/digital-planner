{"ast":null,"code":"'use client';\n\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState, useEffect } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { composeEventHandlers } from '../utils/compose-event-handlers.mjs';\nimport { ScrollAreaScrollbarVisible } from './ScrollAreaScrollbarVisible.mjs';\nconst ScrollAreaScrollbarScroll = forwardRef((props, red) => {\n  const {\n    forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext();\n  const isHorizontal = props.orientation === \"horizontal\";\n  const [state, setState] = useState(\"hidden\");\n  const debounceScrollEnd = useDebouncedCallback(() => setState(\"idle\"), 100);\n  useEffect(() => {\n    if (state === \"idle\") {\n      const hideTimer = window.setTimeout(() => setState(\"hidden\"), context.scrollHideDelay);\n      return () => window.clearTimeout(hideTimer);\n    }\n    return void 0;\n  }, [state, context.scrollHideDelay]);\n  useEffect(() => {\n    const {\n      viewport\n    } = context;\n    const scrollDirection = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n    if (viewport) {\n      let prevScrollPos = viewport[scrollDirection];\n      const handleScroll = () => {\n        const scrollPos = viewport[scrollDirection];\n        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n        if (hasScrollInDirectionChanged) {\n          setState(\"scrolling\");\n          debounceScrollEnd();\n        }\n        prevScrollPos = scrollPos;\n      };\n      viewport.addEventListener(\"scroll\", handleScroll);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll);\n    }\n    return void 0;\n  }, [context.viewport, isHorizontal, debounceScrollEnd]);\n  if (forceMount || state !== \"hidden\") {\n    return /* @__PURE__ */jsx(ScrollAreaScrollbarVisible, {\n      \"data-state\": state === \"hidden\" ? \"hidden\" : \"visible\",\n      ...scrollbarProps,\n      ref: red,\n      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState(\"interacting\")),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState(\"idle\"))\n    });\n  }\n  return null;\n});\nexport { ScrollAreaScrollbarScroll };","map":{"version":3,"names":["ScrollAreaScrollbarScroll","forwardRef","props","red","forceMount","scrollbarProps","context","useScrollAreaContext","isHorizontal","orientation","state","setState","useState","debounceScrollEnd","useDebouncedCallback","useEffect","hideTimer","window","setTimeout","scrollHideDelay","clearTimeout","viewport","scrollDirection","prevScrollPos","handleScroll","scrollPos","hasScrollInDirectionChanged","addEventListener","removeEventListener","jsx","ScrollAreaScrollbarVisible","ref","onPointerEnter","composeEventHandlers","onPointerLeave"],"sources":["C:\\Users\\Soojin Park\\Desktop\\digital-planner\\node_modules\\@mantine\\core\\src\\components\\ScrollArea\\ScrollAreaScrollbar\\ScrollAreaScrollbarScroll.tsx"],"sourcesContent":["import { forwardRef, useEffect, useState } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { composeEventHandlers } from '../utils';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\ninterface ScrollAreaScrollbarScrollProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarScroll = forwardRef<HTMLDivElement, ScrollAreaScrollbarScrollProps>(\n  (props, red) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const isHorizontal = props.orientation === 'horizontal';\n    const [state, setState] = useState<'hidden' | 'idle' | 'interacting' | 'scrolling'>('hidden');\n    const debounceScrollEnd = useDebouncedCallback(() => setState('idle'), 100);\n\n    useEffect(() => {\n      if (state === 'idle') {\n        const hideTimer = window.setTimeout(() => setState('hidden'), context.scrollHideDelay);\n        return () => window.clearTimeout(hideTimer);\n      }\n\n      return undefined;\n    }, [state, context.scrollHideDelay]);\n\n    useEffect(() => {\n      const { viewport } = context;\n      const scrollDirection = isHorizontal ? 'scrollLeft' : 'scrollTop';\n\n      if (viewport) {\n        let prevScrollPos = viewport[scrollDirection];\n        const handleScroll = () => {\n          const scrollPos = viewport[scrollDirection];\n          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n          if (hasScrollInDirectionChanged) {\n            setState('scrolling');\n            debounceScrollEnd();\n          }\n          prevScrollPos = scrollPos;\n        };\n        viewport.addEventListener('scroll', handleScroll);\n        return () => viewport.removeEventListener('scroll', handleScroll);\n      }\n\n      return undefined;\n    }, [context.viewport, isHorizontal, debounceScrollEnd]);\n\n    if (forceMount || state !== 'hidden') {\n      return (\n        <ScrollAreaScrollbarVisible\n          data-state={state === 'hidden' ? 'hidden' : 'visible'}\n          {...scrollbarProps}\n          ref={red}\n          onPointerEnter={composeEventHandlers(props.onPointerEnter, () => setState('interacting'))}\n          onPointerLeave={composeEventHandlers(props.onPointerLeave, () => setState('idle'))}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n"],"mappings":";;;;;;;;AAaO,MAAMA,yBAA4B,GAAAC,UAAA,CACvC,CAACC,KAAA,EAAOC,GAAQ;EACd,MAAM;IAAEC,UAAA;IAAY,GAAGC;EAAA,CAAmB,GAAAH,KAAA;EAC1C,MAAMI,OAAA,GAAUC,oBAAqB;EAC/B,MAAAC,YAAA,GAAeN,KAAA,CAAMO,WAAgB;EAC3C,MAAM,CAACC,KAAA,EAAOC,QAAQ,IAAIC,QAAA,CAA0D,QAAQ;EAC5F,MAAMC,iBAAA,GAAoBC,oBAAqB,OAAMH,QAAS,OAAM,GAAG,GAAG;EAE1EI,SAAA,CAAU,MAAM;IACd,IAAIL,KAAA,KAAU,MAAQ;MACd,MAAAM,SAAA,GAAYC,MAAA,CAAOC,UAAW,OAAMP,QAAA,CAAS,QAAQ,GAAGL,OAAA,CAAQa,eAAe;MAC9E,aAAMF,MAAO,CAAAG,YAAA,CAAaJ,SAAS;IAAA;IAGrC;EACN,IAACN,KAAO,EAAAJ,OAAA,CAAQa,eAAe,CAAC;EAEnCJ,SAAA,CAAU,MAAM;IACR;MAAEM;IAAA,CAAa,GAAAf,OAAA;IACf,MAAAgB,eAAA,GAAkBd,YAAA,GAAe,YAAe;IAEtD,IAAIa,QAAU;MACR,IAAAE,aAAA,GAAgBF,QAAA,CAASC,eAAe;MAC5C,MAAME,YAAA,GAAeA,CAAA,KAAM;QACnB,MAAAC,SAAA,GAAYJ,QAAA,CAASC,eAAe;QAC1C,MAAMI,2BAAA,GAA8BH,aAAkB,KAAAE,SAAA;QACtD,IAAIC,2BAA6B;UAC/Bf,QAAA,CAAS,WAAW;UACFE,iBAAA;QAAA;QAEJU,aAAA,GAAAE,SAAA;MAClB;MACSJ,QAAA,CAAAM,gBAAA,CAAiB,UAAUH,YAAY;MAChD,OAAO,MAAMH,QAAA,CAASO,mBAAoB,WAAUJ,YAAY;IAAA;IAG3D;EAAA,GACN,CAAClB,OAAA,CAAQe,QAAU,EAAAb,YAAA,EAAcK,iBAAiB,CAAC;EAElD,IAAAT,UAAA,IAAcM,KAAA,KAAU,QAAU;IAElC,sBAAAmB,GAAA,CAACC,0BAAA;MACC,cAAYpB,KAAU,gBAAW,QAAW;MAC3C,GAAGL,cAAA;MACJ0B,GAAK,EAAA5B,GAAA;MACL6B,cAAA,EAAgBC,oBAAqB,CAAA/B,KAAA,CAAM8B,cAAA,EAAgB,MAAMrB,QAAA,CAAS,aAAa,CAAC;MACxFuB,cAAA,EAAgBD,oBAAqB,CAAA/B,KAAA,CAAMgC,cAAA,EAAgB,MAAMvB,QAAA,CAAS,MAAM,CAAC;IAAA,CACnF;EAAA;EAIG;AAAA,CAEX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}